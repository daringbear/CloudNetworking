
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Physical Network</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-11-05"><meta name="DC.source" content="PhysicalNetwork.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Physical Network</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Edge Index Mapping</a></li><li><a href="#4">Initialize VNF Specification</a></li><li><a href="#9">Properties</a></li><li><a href="#10">Methods</a></li></ul></div><h2 id="3">Edge Index Mapping</h2><p>In the edge table, link is indexed by rows, which is different from the default index scheme of matlab matrix. So we add a column-index to the Edge Table.</p><h2 id="4">Initialize VNF Specification</h2><h2 id="9">Properties</h2><div><ul><li><b>Topology</b>: including a NodeTable <tt>Nodes</tt> and an EdgeTable <tt>Edges</tt>.</li></ul></div><p><tt>Nodes</tt>: the fields in node table include <i>Name</i>, <i>Location</i>, <i>Capacity</i>, <i>StaticCost</i>, <i>Load</i>, <i>Price</i>.</p><p><tt>Edges</tt>: the fields in the edge table include <i>EndNodes</i>, <i>Weight</i>, <i>Capacity</i>, <i>Index</i>, <i>Load</i>, <i>Price</i>.</p><div><ul><li><b>NumberNodes</b></li><li><b>NumberEdges</b></li><li><b>NumberSlices</b></li><li><b>VNFTable</b>: including following fields.</li></ul></div><p><i>ProcessEfficiency</i>: The coefficient for converting service rate to processing resource  requirement, i.e. <img src="PhysicalNetwork_eq11372758503488575761.png" alt="$ProcessLoad = ServiceRate \times ProcessEfficiency$">;</p><h2 id="10">Methods</h2><div><ul><li><b>LoadNetworkData</b> <tt>static</tt> : generate graph data.</li></ul></div><pre>     graph_data = LoadNetworkData(model, link_opt, node_opt)</pre><div><ul><li><b>LoadVNFData</b> <tt>static</tt> : Generate virtual network function data.</li></ul></div><pre>     VNF_data = LoadVNFData(this, number_VNF, VNF_model)</pre><div><ul><li><b>LinkDelay</b> <tt>static</tt> : convert bandwidth to link delay.</li></ul></div><pre>     dt = LinkDelay(delay_opt, bandwidth)</pre><p><tt>delay_opt</tt>: enumeration type of LinkDelayOption.</p><p><tt>bandwidth</tt>: bandwidth with unit of <tt>Mbps</tt>.</p><p><tt>dt</tt>: delay with unit of <tt>ms</tt>.</p><div><ul><li><b>LinkId</b>: link index of links in the edge table</li></ul></div><pre>     idx = LinkId(this, s, t)</pre><p><tt>s</tt>: source nodes of links;</p><p><tt>t</tt>: tail nodes of links;</p><div><ul><li><b>setLinkField</b>: set the value for a field in the Edge Table. Link price corresponds to column indexed links, so this method is used when a column-indexed data value is provided.</li></ul></div><pre>    setLinkField(this, name, value)</pre><p><tt>name</tt>: a character array represents the field name.</p><p><tt>value</tt>: a column vector stores values to be set for the target field.</p><div><ul><li><b>getLinkField</b>: get the value from a field in the Edge Table. See also setLinkField.</li></ul></div><pre>    value = getLinkField(this, name)</pre><div><ul><li><b>AddSlice</b> : Add Slice to Substrate Network</li></ul></div><pre>    AddSlice(phy_network, slice_opt)</pre><p><tt>slice_opt</tt>:  option for the added slice;</p><div><ul><li><b>AllocateFlowId</b> : Allocate flow identifier.</li></ul></div><pre>    AllocateFlowId(phy_network)</pre><div><ul><li><b>AllocatePathId</b> : Allocate path identifier</li></ul></div><pre>    AllocatePathId(phy_network)</pre><div><ul><li><b>plot</b> : Visualize Substrate Network and Network Slices</li></ul></div><pre>    plot(phy_network)</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Physical Network

%%
classdef PhysicalNetwork < handle
    
    properties (Constant)
        AF0 = 1;      % 1 unit of processing resource per 1Mbps data
        EdgeColor = [ % Predefined set of color data, used to specify the edge color when visualize network.
            0     0     1;    %blue
            0     0.5   0;
            0     0.7   0.7;  
            0.078 0.169 0.549;
            0     0.447 0.741;
            0.494 0.184 0.557;
            0.467 0.675 0.188;
            0.302 0.745 0.933;
            1     0.6   0.78;
           ];
        NodeColor = [ % Predefined set of color data, used to specify the node color when visualize network.
            1     0     0;  %red
            1     0     1;  %magenta
            0.75  0.75  0;
            0.871 0.5   0;
            0.851 0.325 0.098;
            0.25  0.25  0.25];
    end
    
    properties
        
        Topology;
        slices;
        VNFTable;            % Meta data of virtual network function
        
        LinkOption;
        NumberNodes;
        NumberEdges;
        NumberSlices;         % Number of network slices
        NumberVNFs;         

    end
    properties (Access = private)
        graph;
        % mapping link index to edge table index.
        %         edge_table_index;        
    end
    
    methods 
        function this = PhysicalNetwork(graph_data, VNF_data, slice_opt)
            % Store graph information
            %     PhysicalNetwork(graph_data, VNF_opt, slice_opt)
            
            this.graph = DirectedGraph(graph_data);
            this.Topology = graph_data;
            %% Edge Index Mapping
            % In the edge table, link is indexed by rows, which is different from the
            % default index scheme of matlab matrix. So we add a column-index to the Edge
            % Table. 
            [s,t] = graph_data.findedge;
            idx = this.graph.IndexEdge(s,t);
            this.Topology.Edges.Index = idx;
            this.Topology.Edges.Properties.VariableDescriptions{4} = ...
                'Index the edges by column.';
%             [~, this.edge_table_index] = sort(this.Topology.Edges.Index,'ascending');

            %% Initialize VNF Specification
            
            if isfield(VNF_data, 'StaticCost')
                this.Topology.Nodes.StaticCost = VNF_data.StaticCost;
            else
                average_node_capacity = min(this.Topology.Nodes.Capacity);
                switch VNF_data.Model
                    case VNFIntegrateModel.AllInOne
                        rng(VNF_data.RandomSeed(1));
                        this.Topology.Nodes.StaticCost = ...
                            round(average_node_capacity./randi([10 20], [this.NumberNodes, 1]), -2);
                    case VNFIntegrateModel.SameTypeInOne
                        
                    case VNFIntegrateModel.Separated
                        
                end
            end
            this.VNFTable = table;
            if isfield(VNF_data, 'ProcessEfficiency')
                this.VNFTable.ProcessEfficiency = VNF_data.ProcessEfficiency;
            else
                rng(VNF_data.RandomSeed(2));
                this.VNFTable.ProcessEfficiency = 0.5 + rand([VNF_data.Number, 1]);
            end
            
            % Add slice data
            this.NumberSlices = 0;
            this.slices = cell(length(slice_opt),1);
            for i = 1:length(slice_opt)
                this.AddSlice(slice_opt(i));
            end
            
            this.AllocateFlowId;
            this.AllocatePathId;
            for i = 1:length(slice_opt)
                this.slices{i}.initializeState;
                this.slices{i}.Parent = this;
            end
        end
    end
    
    methods
        function opt = get.LinkOption(this)
            opt = this.Topology.Edges.Properties.UserData{1};
        end
        function n = get.NumberNodes(this)
            n = this.Topology.numnodes;
        end
        function m = get.NumberEdges(this)
            m = this.Topology.numedges;
        end
        function n = get.NumberVNFs(this)
            n = height(this.VNFTable);
        end
    end
    
    methods 
        function idx = LinkId(this, s, t)
            % LinkId  get the index of links by the head and tail nodes' id.
            if nargin == 1
                idx = this.graph.IndexEdge;
            elseif nargin == 2
                idx = this.graph.IndexEdge(s);
            else
                idx = this.graph.IndexEdge(s,t);
            end
        end
    
        function setLinkField(this, name, value)
            % setLinkPrice
            %    the link index mapping between DirectedGraph and digraph is as 
            %    follows.
            this.Topology.Edges{:,{name}} = value(this.Topology.Edges.Index);
        end
        function value = getLinkField(this, name)
            % getLinkPrice
            %    link price corresponds to column indexed links.
            value(this.Topology.Edges.Index) = this.Topology.Edges{:,{name}};
        end
        
        optimizeResourcePrice(this, init_link_price, init_node_price);

        AddSlice(this, slice_opt);       
        plot(this);
        
        %         function RemoveSlice(this)
        %         end
        % generate slice data
        %         slice_data = LoadSliceData(this, model);
        
        function AllocateFlowId(this)
            % Allocate flow identifier
            flow_id = 0;
            for i = 1:this.NumberSlices
                slice = this.slices{i};
                slice.FlowTable.Identifier = flow_id + (1:height(slice.FlowTable));
                flow_id = flow_id + height(slice.FlowTable);
            end
        end
        
        %% 
        function AllocatePathId(this)
            % Allocate path identifier
            path_id = 0;
            for i = 1:this.NumberSlices
                for j = 1:height(this.slices{i}.FlowTable)
                    path_list = this.slices{i}.FlowTable.Paths(j).paths;
                    for k = 1:length(path_list)
                        path_id = path_id + 1;
                        path_list{k}.id = path_id;
                    end
                end
            end
        end
        
    end
    
    methods (Static)
        graph_data = LoadNetworkData(model, link_opt, node_opt);
        
        function dt = LinkDelay(delay_opt, bandwidth)
            % link bandwidth-delay convert function
            %     dt = PhysicalNetwork.LinkDelay(delay_opt, bandwidth) convert bandwidth
            %     to delay.
            if delay_opt == LinkDelayOption.BandwidthPropotion
                dt = 0.001*bandwidth;
            elseif delay_opt == LinkDelayOption.BandwidthInverse
                dt = 100./bandwidth;
            else
                error('the delay option (%s) cannot be handled.', delay_opt.char);
            end
        end
    end
    
end

%% Properties
% * *Topology*: including a NodeTable |Nodes| and an EdgeTable |Edges|.
%
% |Nodes|: the fields in node table include _Name_, _Location_, _Capacity_, _StaticCost_,
% _Load_, _Price_.
%
% |Edges|: the fields in the edge table include _EndNodes_, _Weight_, _Capacity_, _Index_,
% _Load_, _Price_.  
%
% * *NumberNodes*
% * *NumberEdges*
% * *NumberSlices*
% * *VNFTable*: including following fields.
%
% _ProcessEfficiency_: The coefficient for converting service rate to processing resource
%  requirement, i.e. $ProcessLoad = ServiceRate \times ProcessEfficiency$;

%% Methods
% * *LoadNetworkData* |static| : generate graph data.
% 
%       graph_data = LoadNetworkData(model, link_opt, node_opt)
%
% * *LoadVNFData* |static| : Generate virtual network function data.
% 
%       VNF_data = LoadVNFData(this, number_VNF, VNF_model)
%
% * *LinkDelay* |static| : convert bandwidth to link delay.
% 
%       dt = LinkDelay(delay_opt, bandwidth)
%
% |delay_opt|: enumeration type of LinkDelayOption.
%
% |bandwidth|: bandwidth with unit of |Mbps|.
%
% |dt|: delay with unit of |ms|.
%
% * *LinkId*: link index of links in the edge table
%
%       idx = LinkId(this, s, t)
%
% |s|: source nodes of links;
%
% |t|: tail nodes of links;
%
% * *setLinkField*: set the value for a field in the Edge Table. Link price corresponds to
% column indexed links, so this method is used when a column-indexed data value is
% provided.
%
%      setLinkField(this, name, value)
%
% |name|: a character array represents the field name.
%
% |value|: a column vector stores values to be set for the target field.
%
% * *getLinkField*: get the value from a field in the Edge Table. See also setLinkField.
%
%      value = getLinkField(this, name)
%
% * *AddSlice* : Add Slice to Substrate Network
%
%      AddSlice(phy_network, slice_opt)
% 
% |slice_opt|:  option for the added slice;
%
% * *AllocateFlowId* : Allocate flow identifier.
%
%      AllocateFlowId(phy_network)
%
% * *AllocatePathId* : Allocate path identifier
%
%      AllocatePathId(phy_network)
%
% * *plot* : Visualize Substrate Network and Network Slices
%
%      plot(phy_network)
##### SOURCE END #####
--></body></html>