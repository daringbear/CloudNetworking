
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Net Social Welfare</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-11-15"><meta name="DC.source" content="optimizeNetSocialWelfare.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Net Social Welfare</h1><!--introduction--><p>Use dual decomposition to find the optimal solution. Compared with the single slice optimization method, this method can decomposit the single optimization into several subproblems with smaller scales corresponding to each slice. thus this method can facilitate to find the optimal solution. In addition, the subproblems can be further decomposited into even smaller scale problems, in which only one user flow is involved. For simplicity, we only decompose the problem on the slice level.</p><p>Despite the advantage of the dual decomposition method, it requires the objective function and constraints are separable. When the cost function is linear, this requirement is easily meeted. However, when the cost function is strictly convex, the resource cost cannot be separated into independent slices.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Dual decomposition</a></li><li><a href="#3">Find the maximum feasible step length in the dual ascent direction.</a></li></ul></div><h2 id="1">Dual decomposition</h2><div><ol><li>An initial point of the dual variable is given as &#955;=1 (all constraint is active) or 0 (the Lagrangian only contains objective function). &#955; = [&#955;(p,f,s), &#955;(n), &#955;(e)]</li><li>Independently solve the subproblems for each slice.</li><li>Update the dual variable</li><li>Repeat the second and third steps, until the optimal solution is reached. which can be varified by the function value, or the optimal (KKT) condition.</li></ol></div><h2 id="3">Find the maximum feasible step length in the dual ascent direction.</h2><div><ol><li>Determine maximum feasible step length (less than the default step length) for &#955;&gt;=0. the dual variable after the updates must still be in the feasible domain.</li><li>Determine maximum step length (less than the feasible step length) of &#955;_n for g(z)&gt;=0. #Determine maximum step length of &#955;_pf for g(z)&gt;=0. After finding the maximum step length for &#955;_n, we calculate the step length for &#955;_pf of each slice, and then update the dual variables using the new step length.</li></ol></div><p><b>Note</b>: finding an conmmon feasible step length for all dual variable is not right, since in some direction the dual variable has reach the boundaries of &#955; of g(z,&#955;).</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Net Social Welfare
% Use dual decomposition to find the optimal solution.
% Compared with the single slice optimization method, this method can decomposit the
% single optimization into several subproblems with smaller scales corresponding to each
% slice. thus this method can facilitate to find the optimal solution. In addition, the
% subproblems can be further decomposited into even smaller scale problems, in which only
% one user flow is involved. For simplicity, we only decompose the problem on the slice
% level.
%
% Despite the advantage of the dual decomposition method, it requires the objective
% function and constraints are separable. When the cost function is linear, this
% requirement is easily meeted. However, when the cost function is strictly convex, the
% resource cost cannot be separated into independent slices.
%% Dual decomposition
% # An initial point of the dual variable is given as λ=1 (all constraint is active)
% or 0 (the Lagrangian only contains objective function).
% λ = [λ(p,f,s), λ(n), λ(e)]
% # Independently solve the subproblems for each slice.
% # Update the dual variable
% # Repeat the second and third steps, until the optimal solution is reached.
% which can be varified by the function value, or the optimal (KKT) condition.

function [new_profit] = optimizeNetSocialWelfare( this )
NN = this.NumberNodes;
NS = this.NumberSlices;
NL = this.NumberLinks;
node_capacity = this.getNodeField('Capacity');
link_capacity = this.getLinkField('Capacity');
node_unit_cost = this.getNodeField('UnitCost');
phis_n = this.staticNodeCost*this.Delta*(NN-1)/this.totalNodeCapacity;
lambda.pf = cell(NS,1);
% lambda.p = cell(NS,1);
% lambda.npf = cell(NS,1);
for i = 1:NS
    lambda.pf{i} = ones(this.slices{i}.NumberPaths, this.slices{i}.NumberVNFs);
    %     lambda.p{i} = ones(this.slices{i}.NumberPaths, 1);
    %     lambda.npf{i} = ones(this.slices{i}.NumberVirtualNodes, this.slices{i}.NumberPaths, ...
    %         this.slices{i}.NumberVNFs);
end
lambda.n = ones(NN, 1);
lambda.e = ones(NL, 1);
delta_lambda = lambda;
% storage for subproblem results
% the results are mapped from slices to substrate network
node_load = zeros(NS, NN);
link_load = zeros(NS, NL);

iter_num = 1;
old_profit = 0;
new_profit = -inf;
while abs(new_profit-old_profit) > 10^-1
    old_profit = new_profit;
    step_length = 1/sqrt(iter_num);     % step for lambda_n, default_step = 1;
    step_n = step_length*ones(NN,1);
    alpha_idx = delta_lambda.n<0;
    step_n(alpha_idx) = min(step_n(alpha_idx), lambda.n(alpha_idx)./delta_lambda.n(alpha_idx));
    step_pf = cell(NS,1);
    total_utility = 0;
    for i = 1:NS
        lambda_i = struct('pf', lambda.pf{i}, ...
            'n', lambda.n(this.slices{i}.VirtualNodes.PhysicalNode),...
            'e', lambda.e(this.slices{i}.VirtualLinks.PhysicalLink));
        [node_load(i,:), link_load(i,:), g_pf] = ...
            this.slices{i}.subproblemNetSocialWelfare(lambda_i);
        total_utility = total_utility + ...
            this.slices{i}.weight*sum(log(this.slices{i}.flow_rate));
        delta_lambda.pf{i} = g_pf;
        step_pf{i} = step_length*ones(1, NPi, NFi);
        alpha_idx = delta_lambda.pf{i}<0;
        step_pf{i}(alpha_idx) = min(step_pf{i}(alpha_idx), ...
            lambda.pf{i}(alpha_idx)./delta_lambda.pf{i}(alpha_idx));
    end
    delta_lambda.n = (sum(node_load,1))'-node_capacity;
    delta_lambda.e = (sum(link_load,1))'-link_capacity;
    
    %% Find the maximum feasible step length in the dual ascent direction.
    % # Determine maximum feasible step length (less than the default step length)
    % for λ>=0. the dual variable after the updates must still be in the feasible domain.
    % # Determine maximum step length (less than the feasible step length) of λ_n
    % for g(z)>=0.
    % #Determine maximum step length of λ_pf for g(z)>=0.
    % After finding the maximum step length for λ_n, we calculate the step length for λ_pf
    % of each slice, and then update the dual variables using the new step length.
    %
    % *Note*: finding an conmmon feasible step length for all dual variable is not right,
    % since in some direction the dual variable has reach the boundaries of λ of g(z,λ).
    for i = 1:NS
        NPi = this.slices{i}.NumberPaths;
        NFi = this.slices{i}.NumberVNFs;
        NNi = this.slices{i}.NumberNodes;
        nid = this.slices{i}.VirtualNodes.PhysicalNode;
        lambda_pf = repmat(repmat(lambda.pf{i}, 1, NPi, NFi), NNi, 1, 1);
        delta_lambda_pf = repmat(step_length*delta_lambda.pf{i}, 1, NPi, NFi);
        delta_lambda_pf = repmat(delta_lambda_pf, NNi,1,1);
        % compatible addition , gradz and delta_gradz result in 3D arraies, with dimension of N*P*F
        gradz = node_unit_cost(nid) + phis_n + lambda.n(nid)-lambda_pf;
        delta_gradz = delta_lambda.n(nid) - delta_lambda_pf;
        
        alpha_npf = min(step_n(nid).*ones(NNi, NPi, NFi), repmat(step_pf{i}, NNi, 1, 1));
        % if delta_gradz>=0, then any feasible step lengths still guarantees than gradz is postive.
        % otherwise, a appropriate value of step length must be calculated.
        alpha_idx = delta_gradz<0;
        alpha_npf(alpha_idx) = -gradz(alpha_idx)./delta_gradz(alpha_idx);
        a1 = min(min(alpha_npf, [], 3), [], 1);		% find the maximum (max-min) step length for λ_n in slice i.
        % compare the maximum step length with the prior calculated value and and update it.
        step_n(nid) = min(step_n(nid), a1);
    end
    lambda.n = lambda.n + step_n.*delta_lambda.n;
    
    for i = 1:NS
        NPi = this.slices{i}.NumberPaths;
        NFi = this.slices{i}.NumberVNFs;
        NNi = this.slices{i}.NumberNodes;
        nid = this.slices{i}.VirtualNodes.PhysicalNode;
        lambda_pf = repmat(repmat(lambda.pf{i}, 1, NPi, NFi), NNi, 1, 1);
        delta_lambda_pf = repmat(step_length*delta_lambda.pf{i}, 1, NPi, NFi);
        delta_lambda_pf = repmat(delta_lambda_pf, NNi,1,1);
        gradz = node_unit_cost(nid) + phis_n + lambda.n(nid)-lambda_pf + step_n(nid).*delta_lambda.n(nid);
        % if delta_lambda_pf<= 0, any positive step length for λ_pf is feasible.
        % otherwise, we calculate a feasible step length
        alpha_npf = repmat(step_pf{i}, NNi, 1, 1);
        alpha_idx = delta_lambda_pf>0;
        alpha_npf(alpha_idx) = gradz(alpha_idx)./delta_lambda_pf;
        a2 = repmat(min(alpha_npf, [], 1), NPi, NFi);
        lambda.pf{i} = lambda.pf{i} + a2.*delta_lambda.pf{i};
    end
    
    % dual variables on links are not related to gradients on z, the step length is the default step length.
    lambda.e = lambda.e + step_length*(delta_lambda.e);
    lambda.e(lambda.e<0) = 0;
    
    theta = this.networkUtilization(sum(node_load,1), sum(link_load,1));
    new_profit = total_utility - this.getNodeCost(sum(node_load,1))...
        - this.getLinkCost(sum(link_load,1))...
        - this.staticNodeCost*((this.NumberNodes-1)*theta+1);
    fprintf('\tNew profit: %.3e, old profit: %.3e, difference: %.3e.\n', ...
        new_profit, old_profit, abs(new_profit-old_profit));
    iter_num = iter_num + 1;
end

% output
fprintf('\tOptimal net social welfare %G.\n', new_profit);
end
##### SOURCE END #####
--></body></html>