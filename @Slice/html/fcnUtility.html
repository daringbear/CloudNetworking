
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Evalute the objective function and gradient</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-11-16"><meta name="DC.source" content="fcnUtility.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Evalute the objective function and gradient</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Gradient value of the objective function</a></li></ul></div><h2 id="3">Gradient value of the objective function</h2><p>The upper bound number of non-zero elements in the gradient vector:  the gradient on path variable is nonzeros, so there is <tt>P</tt> components;  whether the gradient on node variable is zeros is decided by the node-path  incidence matrix, i.e. <tt>nnz(I_node_path)*F</tt>.</p><p>Gradient on <tt>x(p)</tt> is given by</p><p><img src="fcnUtility_eq00552389634110994564.png" alt="$$\frac{\partial f}{\partial x(p)} = -\frac{1}{\sum_{p_0\in\mathcal{P}_{i_p}}{x_{p_0}}}=&#xA;  -\frac{1}{\sum_{p_0\in\mathcal{P}_{i_p}}{q_{i_p,p_0}\cdot x_{p_0}}} =&#xA;  -\sum_{i}{\frac{q_{i,p}}{\sum_{p_0\in\mathcal{P}}{q_{i,p}\cdot x_{p_0}}}}$$"></p><p>and gradient on <tt>z(n,p,f)</tt> is given by</p><p><img src="fcnUtility_eq14030288744227969494.png" alt="$$ \frac{\partial f}{\partial z(n,p,f)} = \rho_n\cdot h_{n,p} $$"></p><p>To obtain the derivatives on <tt>z</tt>, each step we fix the function index <tt>f</tt>. i.e.</p><p><img src="fcnUtility_eq00157281903017537890.png" alt="$$\frac{\partial f}{\partial z(n,p,f)}=h_{n,p}, \forall n \in \mathcal{N}$$"></p><p>So, we can compute the derivatives for all <tt>n</tt> and <tt>p</tt> with fixed <tt>f</tt>, which consist a matrix <img src="fcnUtility_eq05297576075861136825.png" alt="$h_{n,p}$">, and can be converted into a column vector.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Evalute the objective function and gradient
%
%%
function [profit, grad]= fcnUtility(var_x, S)
var_path = var_x(1:S.NumberPaths);
var_node = var_x((S.NumberPaths+1):end);
flow_rate = S.getFlowRate(var_path);
edge_load = S.getLinkLoad(var_path);
node_load = S.getNodeLoad(var_node);
link_price = S.VirtualLinks.Price;
node_price = S.VirtualNodes.Price;

profit = -S.weight*sum(log(flow_rate)) ...
    + dot(link_price, edge_load) + dot(node_price, node_load);

grad = spalloc(length(var_x),1, S.NumberPaths+nnz(S.I_node_path)*S.NumberVNFs);

%% Gradient value of the objective function
% The upper bound number of non-zero elements in the gradient vector:
%  the gradient on path variable is nonzeros, so there is |P| components;
%  whether the gradient on node variable is zeros is decided by the node-path
%  incidence matrix, i.e. |nnz(I_node_path)*F|.
%
% Gradient on |x(p)| is given by
%
% $$\frac{\partial f}{\partial x(p)} = -\frac{1}{\sum_{p_0\in\mathcal{P}_{i_p}}{x_{p_0}}}=
%   -\frac{1}{\sum_{p_0\in\mathcal{P}_{i_p}}{q_{i_p,p_0}\cdot x_{p_0}}} = 
%   -\sum_{i}{\frac{q_{i,p}}{\sum_{p_0\in\mathcal{P}}{q_{i,p}\cdot x_{p_0}}}}$$
%
% and gradient on |z(n,p,f)| is given by
% 
% $$ \frac{\partial f}{\partial z(n,p,f)} = \rho_n\cdot h_{n,p} $$
%
% To obtain the derivatives on |z|, each step we fix the function index |f|. i.e.
% 
% $$\frac{\partial f}{\partial z(n,p,f)}=h_{n,p}, \forall n \in \mathcal{N}$$ 
%
% So, we can compute the derivatives for all |n| and |p| with fixed |f|, which consist a
% matrix $h_{n,p}$, and can be converted into a column vector.
for p = 1:S.NumberPaths
    i = S.path_owner(p);
    grad(p) = -S.weight/(S.I_flow_path(i,:)*var_path) + ...
        link_price'*S.I_edge_path(:,p); %#ok<SPRIX>   
end

z_index = S.NumberPaths+1:(S.NumberVirtualNodes*S.NumberPaths);
for f = 1:S.NumberVNFs
    % compatible arithmetic operation: node_price is a row vector and S.I_node_path is a
    % matrix, and these two operants have the same number of rows.
    gz = node_price.*S.I_node_path;
    grad(z_index) = gz(:); %#ok<SPRIX>
    z_index = z_index + S.NumberVirtualNodes;
end
end
##### SOURCE END #####
--></body></html>