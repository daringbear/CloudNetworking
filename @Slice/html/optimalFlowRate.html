
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>optimalFlowRate</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-20"><meta name="DC.source" content="optimalFlowRate.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Coefficient for process-rate constriants</a></li><li><a href="#4">Coefficient</a></li><li><a href="#6">Add link and node capacity constrant coefficient.</a></li><li><a href="#7">boundary</a></li><li><a href="#8">Feasible test of start point</a></li><li><a href="#9">Additional Process</a></li><li><a href="#11">when compute node load, z_npf corresonding to h_np = 0 has been set as zero.</a></li><li><a href="#13">Additional Process</a></li><li><a href="#14">when compute node load, z_npf corresonding to h_np = 0 has been set as zero.</a></li></ul></div><h2 id="3">Coefficient for process-rate constriants</h2><h2 id="4">Coefficient</h2><p>If VNF f is not used by a path p (the corresponding flow), there is no constraints on <tt>f x p</tt>.</p><h2 id="6">Add link and node capacity constrant coefficient.</h2><h2 id="7">boundary</h2><h2 id="8">Feasible test of start point</h2><p><b>Start Point</b></p><h2 id="9">Additional Process</h2><div><ul><li>When compute node load, <tt>z_npf</tt> corresonding to <tt>h_np = 0</tt> has been set as zero. only path use a node and path use a function, the variable <tt>z_npf</tt> is nonzero.</li><li>too small components should be rounded.</li></ul></div><h2 id="11">when compute node load, z_npf corresonding to h_np = 0 has been set as zero.</h2><h2 id="13">Additional Process</h2><p>too small components should be rounded.-     x(x &lt; 1) = 0;</p><h2 id="14">when compute node load, z_npf corresonding to h_np = 0 has been set as zero.</h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
function [ utility ] = optimalFlowRate( this, options )
if nargin <= 1
    options.Display = 'final';
    options.Method = 'slice';
else
    if ~isfield(options, 'Display')
        options.Display = 'final';
    end
    if ~isfield(options, 'Method')
        options.Method = 'slice';
    end
end

NL = this.NumberVirtualLinks;
NN = this.NumberVirtualNodes;
NV = this.NumberVNFs;
NP = this.NumberPaths;

%% Coefficient for process-rate constriants
if strcmp(options.Method, 'normal')
    %% Coefficient
    % If VNF f is not used by a path p (the corresponding flow), there is no constraints
    % on |f x p|.    
    idx = 1:NP;
    for v = 1:NV
        vid = this.VNFList(v);
        delete_items = this.I_path_function(:,vid)==0;
        this.As_res(idx(delete_items),:) = [];
        idx = idx + nnz(this.I_path_function(:,vid));
    end
end
nnz_As = nnz(this.As_res) + NV*nnz(this.I_node_path) + nnz(this.I_edge_path);
num_lcon = this.num_lcon_res + NN + NL;
As = spalloc(num_lcon, this.num_vars, nnz_As);
As(1:this.num_lcon_res,:) = this.As_res;

%% Add link and node capacity constrant coefficient.
col_index = NP+(1:NN:((NP-1)*NN+1))';
col_index = repmat(col_index, 1, NV);
for v = 2:NV
    col_index(:,v) = col_index(:,v-1) + NN*NP;
end
col_index = col_index(:);
row_index = this.num_lcon_res;
for n = 1:NN
    As(row_index+n, col_index) = repmat(this.I_node_path(n,:),1, NV);
    col_index = col_index + 1;
end
row_index = (1:NL) + this.num_lcon_res + NN;
As(row_index, 1:NP) = this.I_edge_path; 

%% boundary
bs = [sparse(this.num_lcon_res,1); 
    this.VirtualNodes.Capacity;
    this.VirtualLinks.Capacity];
lbs = sparse(this.num_vars,1);

%% Feasible test of start point
% *Start Point*
x0 = zeros(this.num_vars,1);
z_min = min(this.VirtualNodes.Capacity)/(NP*NV);
x_min = min(this.VirtualLinks.Capacity)/NP;
if strcmp(options.Method, 'single-function')
    max_alpha_f = max(this.alpha_f);
elseif strcmp(options.Method, 'normal')
    max_alpha_f = max(this.Parent.VNFTable.ProcessEfficiency);
else
    max_alpha_f = max(this.Parent.VNFTable{this.VNFList, 'ProcessEfficiency'});
end
if z_min >= max_alpha_f*x_min  % [x,z] is feasible
    x0(1:NP) = x_min;
    x0((NP+1):end) = z_min;
else
    x0(1:NP) = z_min/max_alpha_f;
    x0((NP+1):end) = z_min;    
end
% x0(1:NP) = 1;
% max_alpha_f = max(this.Parent.VNFTable.ProcessEfficiency(this.VNFList));
% x0((NP+1):end) = max_alpha_f;
if ~this.checkFeasible(x0)
    error('error: infeasible start point.');
end

fmincon_opt = optimoptions(@fmincon);
fmincon_opt.Algorithm = 'interior-point';
fmincon_opt.HessianFcn = @(x,lambda)Slice.fcnHessian(x,lambda,this);
fmincon_opt.SpecifyObjectiveGradient = true;
fmincon_opt.SpecifyConstraintGradient = false;
if nargin >= 2 && isfield(options, 'Display')
    fmincon_opt.Display = options.Display;
else
    fmincon_opt.Display = 'notify-detailed';  %'iter';
end
[x, fval, exitflag] = fmincon(@(x)Slice.fcnNetWelfare(x,this), ...
    x0, As, bs, [], [], lbs, [], [], fmincon_opt);
if exitflag < 1
    error('abnormal exit with flag %d.',exitflag);
end
if ~this.checkFeasible(x, options)
    error('error: infeasible solution.');
end

%% Additional Process
% * When compute node load, |z_npf| corresonding to |h_np = 0| has been set as zero.
% only path use a node and path use a function, the variable |z_npf| is nonzero.
% * too small components should be rounded.
this.x_path = x(1:NP);
if strcmp(options.Method, 'normal')
    znpf = x(NP+1:end);
    this.z_npf = zeros(NN*NP*this.Parent.NumberVNFs,1);
    nz = this.NumberVirtualNodes*this.NumberPaths;
    z_index = 1:nz;
    new_z_index = z_index;
    for v = 1:this.Parent.NumberVNFs
%         if b_vnf(v)
            mask_npf = ss.I_node_path.*this.I_path_function(:,v)';
            ss.z_npf(new_z_index) = mask_npf(:).*znpf(z_index);
            z_index = z_index + nz;
%         end
        new_z_index = new_z_index + nz;
    end
    ss.Variables.x = ss.x_path;
    ss.Variables.z = ss.z_npf;
elseif strcmp(options.Method, 'single-function')
    slice_data.VNFList = 1:this.NumberVNFs;
    ss = Slice(slice_data);
    ss.x_path = x(1:NP);
    ss.Variables.x = ss.x_path;
    %% when compute node load, z_npf corresonding to h_np = 0 has been set as zero.
    z_np = x(NP+1:end);
    z_np = reshape(ss.I_node_path(:).*z_np, NN,NP);    
    znpf = zeros(NN, NP, this.NumberVNFs);
    for v = 1:this.NumberVNFs
        af = this.VNFTable.ProcessEfficiency(v);
        idx_path = I_path_function(:,v)==1;
        p_slice = ss.path_owner(idx_path);
        znpf(:, idx_path, v) = z_np(:, idx_path).*(af./slice_data.alpha_f(p_slice))';
    end
    ss.Variables.z = znpf(:);
else
    this.z_npf = x(NP+1:end);

end

%% Additional Process
% too small components should be rounded.-
%     x(x < 1) = 0;

%% when compute node load, z_npf corresonding to h_np = 0 has been set as zero.
nz = this.NumberVirtualNodes*this.NumberPaths;
z_index = 1:nz;
for v = 1:NV
    this.z_npf(z_index) = this.I_node_path(:).*this.z_npf(z_index);
    z_index = z_index + nz;
end
this.Variables.x = this.x_path;
this.Variables.z = this.z_npf;
this.Variables.z(this.Variables.z<10^-3) = 0;
this.Variables.x(this.Variables.x<10^-3) = 0;
if ~this.checkFeasible
    warning('optimalFlowRate: the rounding of variables with small quantity will make the solution infeasible.');
end
this.setPathBandwidth;
this.FlowTable.Rate = this.getFlowRate;
this.VirtualLinks.Load = this.getLinkLoad;
this.VirtualNodes.Load = this.getNodeLoad;
utility = -fval;
end


##### SOURCE END #####
--></body></html>