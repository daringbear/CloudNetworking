
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Network Slice</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-11-04"><meta name="DC.source" content="readme.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Network Slice</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Properties</a></li><li><a href="#2">Methods</a></li></ul></div><h2 id="1">Properties</h2><div><ul><li><b>Topology</b>  : Normally, the network slice will not run shrtest path algorithm, so the absolute value of the adjacent matrix of Topology does not matter. On the other hand, the link and node capacity of the slice is also not determined until the substrate network allocate the resource to the slice.</li><li><b>VirtualLinkMap</b> : fields include <i>PhysicalLink</i>, <i>Price</i>, <i>Load</i>.</li><li><b>VitrualNodeMap</b> : fields include <i>PhysicalNode</i>, <i>Price</i>, <i>Load</i>.</li></ul></div><div><ul><li><b>NumberNodes</b> <tt>get</tt></li></ul></div><div><ul><li><b>NumberNodes</b> <tt>get</tt></li></ul></div><div><ul><li><b>NumberFlows</b> <tt>get</tt></li></ul></div><div><ul><li><b>NumberPaths</b> <tt>get</tt></li></ul></div><h2 id="2">Methods</h2><div><ul><li><b>getPathId</b> : find the path's local identifier.</li></ul></div><pre>    pid = getPathId(slice, path)</pre><div><ul><li><b>optimalFlowRate</b> : find the optimal flow rate that maximizing the net profit of the network slice.</li></ul></div><pre>    x = optimalFlowRate(this, x0)</pre><div><ul><li><b>optimalFlowRateCompact</b> : find the optimal flow rate that maximizing the net profit of the network slice.</li></ul></div><pre>    x = optimalFlowRateCompact(this, x0)</pre><p>The optimizition procedure in this method remove the unnecessary components from the independent variable <tt>x</tt>, so that the problem scale is cut down.</p><div><ul><li><b>fcnUtility</b> <tt>static</tt> : Evalute the objective function and gradient.</li></ul></div><pre>    [profit, grad]= fcnUtility(var_x, S)</pre><p><tt>grad</tt>: the gradient value of the objective function. The upper bound number of non-zero elements in the gradient vector: the gradient on path variable is nonzeros, so there is <tt>P</tt> components; whether the gradient on node variable is zeros is decided by the node-path incidence matrix, i.e. <tt>nnz(I_node_path)*F</tt>.</p><div><ul><li><b>fcnUtilityCompact</b> <tt>static</tt> : Evalute the objective function and gradient.</li></ul></div><pre>    [profit, grad]= fcnUtilityCompact(act_var_x, S)</pre><p>Only active independent variables are passed into the objective function.</p><div><ul><li><b>fcnHessian</b> <tt>static</tt> : Hessian matrix of the Largrangian.</li></ul></div><pre>    hess = fcnHessian(var_x, ~, S)</pre><p>Since the problem only contains linear constraint, the hessian matrix of the Largrangian is equal to the second derivatives of the objective function, and the Largrangian multipliers <img src="readme_eq07657233533591063549.png" alt="$\lambda$"> takes no effect. The Hessian matrix contains only <img src="readme_eq13491182207080100242.png" alt="$P^2$"> nonzeros elements on the diagonal, which is the second derviatives on path variables.</p><div><ul><li><b>fcnHessianCompact</b> <tt>static</tt> : Compact form of Hessian matrix of the Largrangian.</li></ul></div><pre>    hess = fcnHessianCompact(act_var_x, ~, S)</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Network Slice

%% Properties
% * *Topology*
%  : Normally, the network slice will not run shrtest path algorithm, so the absolute
% value of the adjacent matrix of Topology does not matter. On the other hand, the
% link and node capacity of the slice is also not determined until the substrate
% network allocate the resource to the slice.
% * *VirtualLinkMap* : fields include _PhysicalLink_, _Price_, _Load_.
% * *VitrualNodeMap* : fields include _PhysicalNode_, _Price_, _Load_.
%
% * *NumberNodes* |get|
%
% * *NumberNodes* |get|
%
% * *NumberFlows* |get|
%
% * *NumberPaths* |get|

%% Methods
% * *getPathId* : find the path's local identifier.
% 
%      pid = getPathId(slice, path)
%
% * *optimalFlowRate* : find the optimal flow rate that maximizing the net profit of the
% network slice.
% 
%      x = optimalFlowRate(this, x0)
% 
% * *optimalFlowRateCompact* : find the optimal flow rate that maximizing the net profit
% of the network slice.
% 
%      x = optimalFlowRateCompact(this, x0) 
%
% The optimizition procedure in this method remove the unnecessary components from the
% independent variable |x|, so that the problem scale is cut down.
%
% * *fcnUtility* |static| : Evalute the objective function and gradient.
%
%      [profit, grad]= fcnUtility(var_x, S)
%
% |grad|: the gradient value of the objective function. 
% The upper bound number of non-zero elements in the gradient vector: the gradient on path
% variable is nonzeros, so there is |P| components; whether the gradient on node variable
% is zeros is decided by the node-path incidence matrix, i.e. |nnz(I_node_path)*F|.
%
% * *fcnUtilityCompact* |static| : Evalute the objective function and gradient.
%
%      [profit, grad]= fcnUtilityCompact(act_var_x, S)
%
% Only active independent variables are passed into the objective function. 
%
% * *fcnHessian* |static| : Hessian matrix of the Largrangian.
% 
%      hess = fcnHessian(var_x, ~, S)
%
% Since the problem only contains linear constraint, the hessian matrix of the
% Largrangian is equal to the second derivatives of the objective function, and the
% Largrangian multipliers $\lambda$ takes no effect.
% The Hessian matrix contains only $P^2$ nonzeros elements on the diagonal,
% which is the second derviatives on path variables.
%
% * *fcnHessianCompact* |static| : Compact form of Hessian matrix of the Largrangian.
%
%      hess = fcnHessianCompact(act_var_x, ~, S)
##### SOURCE END #####
--></body></html>